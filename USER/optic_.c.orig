#include "stm32f10x.h"
#include "optic_.h"
uint8_t Mini_Flow_SSI,Mini_Flow_SSI_CNT;
uint8_t mini_flow_flag;
_flow flow;
//光流数据接收
void Player_Flow_Receive(uint8_t data)
{
	static uint8_t RxBuffer[32];
	static uint8_t _data_cnt = 0;
	static uint8_t state = 0;
	uint8_t sum = 0;
	
	switch(state)
	{
		case 0:
			if(data==0xFE)//包头
			{
				state=1;
				RxBuffer[_data_cnt++]=data;
			}else state = 0;
		break;
			
		case 1:
			if(data==0x04)//字节数
			{
				state=2;
				RxBuffer[_data_cnt++]=data;
			}else state = 0;
		break;
			
		case 2:
			RxBuffer[_data_cnt++]=data;
		
			if(_data_cnt==9)
			{
				state = 0;
				_data_cnt = 0;
				
				sum =  (RxBuffer[2] + RxBuffer[3] + RxBuffer[4] + RxBuffer[5]);
				
				if((0xAA == data) && (sum == RxBuffer[6])) //和校验
				{
					Mini_Flow_SSI_CNT++;//测试光流数据帧率
					
					flow.x = ( (s16)(*(RxBuffer+3)<<8)|*(RxBuffer+2) );
					flow.y = ( (s16)(*(RxBuffer+5)<<8)|*(RxBuffer+4) );
					mini_flow_flag=1;
				}
			}
		break;
			
		default:	
			state = 0;
			_data_cnt = 0;
		break;
	}
}
extern u16 Sonar_alt_u;
extern u16 Sonar_flag;
	extern uint8_t flag_dis;

void proto_dis(uint8_t c)//超声波获取到的距离
{
	static u8 buf_test[256];
	static u8 flag_i=0;
	static uint8_t val,dis;
	flag_i++;
	if(flag_i==255)flag_i=0;
	buf_test[flag_i]=c;
    if(flag_dis==2)
    {
        val=c;
        flag_dis=3;
    }
    if(flag_dis==1)
    {
        dis=c;
        flag_dis=2;

    }
    if(flag_dis==3)
    {
        Sonar_alt_u=dis<<8|val;
			Sonar_alt_u=Sonar_alt_u/10;
    }

}


	/*////////////////////////////
//定时器1通道1输入捕获配置


void TIM2_Cap_Init(u16 arr,u16 psc)
{
    TIM_ICInitTypeDef  TIM2_ICInitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;
    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    RCC->APB1ENR |=1<< 0;//使能定时器2，TIM2
    RCC->APB2ENR|=1<<2;            //使能PORTA时钟

    GPIOA->CRL &= 0XFFFFFF0F;//PA1清零
    GPIOA->CRL |= 0X00000080;//输入
    GPIOA->ODR|=0<<1;                //PA1 下拉

    TIM2->ARR=arr;                  //设定计数器自动重装值
    TIM2->PSC=psc;                  //预分频

    TIM2->CCMR1|=1<<8;                //CC2S=10         选择输入端 IC2映射到TI2上
    TIM2->CCMR1|=0<<12;                 //IC2F=0001 配置输入滤波器 不滤波
    TIM2->CCMR1|=0<<10;         //IC2PS=00         配置输入分频,不分频

    TIM2->CCER|=0<<5;                 //CC2P=0        上升沿捕获
    TIM2->CCER|=1<<4;                 //CC2E=1         允许捕获计数器的值到捕获寄存器中

    TIM2->DIER|=1<<2;           //允许捕获中断CC2IE=1
    TIM2->DIER|=1<<0;           //允许更新中断UIE=1
    TIM2->CR1|=0x01;            //使能定时器2
    //初始化TIM2输入捕获参数
    TIM2_ICInitStructure.TIM_Channel = TIM_Channel_2; //CC1S=01 	选择输入端 IC1映射到TI1上
    TIM2_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	//上升沿捕获
    TIM2_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //映射到TI1上
    TIM2_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	 //配置输入分频,不分频
    TIM2_ICInitStructure.TIM_ICFilter = 0x00;//IC1F=0000 配置输入滤波器 不滤波
    TIM_ICInit(TIM2, &TIM2_ICInitStructure);

    //中断分组初始化
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;  //TIM1中断
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;  //先占优先级2级
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;  //从优先级0级
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
    NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器

    TIM_ITConfig(TIM2,TIM_IT_Update|TIM_IT_CC2,ENABLE);//允许更新中断 ,允许CC1IE捕获中断

    TIM_Cmd(TIM2,ENABLE ); 	//使能定时器1




}

u8  TIM2CH2_CAPTURE_STA=0;	//输入捕获状态
u16	TIM2CH2_CAPTURE_VAL;

void TIM2_IRQHandler(void)
{

    if((TIM1CH1_CAPTURE_STA&0X80)==0)//还未成功捕获
    {
        if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)

        {
            if(TIM2CH2_CAPTURE_STA&0X40)//已经捕获到高电平了
            {
                if((TIM2CH2_CAPTURE_STA&0X3F)==0X3F)//高电平太长了
                {
                    TIM2CH2_CAPTURE_STA|=0X80;//标记成功捕获了一次
                    TIM2CH2_CAPTURE_VAL=0XFFFF;
                } else TIM2CH2_CAPTURE_STA++;
            }
        }
        if (TIM_GetITStatus(TIM2, TIM_IT_CC2) != RESET)//捕获1发生捕获事件
        {
            if(TIM2CH2_CAPTURE_STA&0X40)		//捕获到一个下降沿
            {
                TIM2CH2_CAPTURE_STA|=0X80;		//标记成功捕获到一次高电平脉宽
                TIM2CH2_CAPTURE_VAL=TIM_GetCapture2(TIM2);
                TIM_OC1PolarityConfig(TIM2,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获
            } else  								//还未开始,第一次捕获上升沿
            {
                TIM2CH2_CAPTURE_STA=0;			//清空
                TIM1CH1_CAPTURE_VAL=0;
                TIM_SetCounter(TIM2,0);
                TIM2CH2_CAPTURE_STA|=0X40;		//标记捕获到了上升沿
                TIM_OC1PolarityConfig(TIM2,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获
            }
        }
    }

    //处理帧数据
    if(TIM2CH2_CAPTURE_STA&0X80)//成功捕获到了一次上升沿
    {

        TIM1CH1_CAPTURE_STA=0;//开启下一次捕获

    }




    TIM_ClearITPendingBit(TIM2, TIM_IT_CC2|TIM_IT_Update); //清除中断标志位

}
*/
